package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"chat_application/api/auth"
	"chat_application/api/dal"
	"chat_application/graph/model"
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// CreateVideo is the resolver for the createVideo field.
func (r *mutationResolver) CreateVideo(ctx context.Context, input model.NewVideo) (*model.Video, error) {
	fmt.Println("in createvideo")
	raw, _ := ctx.Value(auth.UserCtxKey).(int)
	fmt.Println(raw)
	newVideo := &model.Video{
		URL:         input.URL,
		Description: input.Description,
		Name:        input.Name,
	}
	var errr error
	return newVideo, errr
}

// PersonalConversation is the resolver for the personalConversation field.
func (r *mutationResolver) PersonalConversation(ctx context.Context, input model.NewPersonalConversation) (*model.PersonalConversation, error) {
	var PersonalConversation model.PersonalConversation
	receiverID, err := r.Query().UserIDByName(ctx, &input.ReceiverName)
	if err != nil {
		return &PersonalConversation, err
	}
	db := dal.GetDB()
	senderID := ctx.Value(auth.UserCtxKey).(int)
	currentTime := time.Now()
	outputFormat := "2006-01-02 15:04:05-07:00"
	currentFormattedTime := currentTime.Format(outputFormat)
	errIfNoRows := db.QueryRow(
		"INSERT INTO public.personal_conversations( sender_id, receiver_id, content, created_at) VALUES ( $1, $2, $3, $4)  RETURNING id;", senderID, receiverID, input.Content, currentFormattedTime).Scan(&PersonalConversation.ID)
	if errIfNoRows == nil {
		PersonalConversation.CreatedAt = currentFormattedTime
		return &PersonalConversation, nil
	}
	return nil, errIfNoRows
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.NewGroup) (*model.Group, error) {
	var  Group model.Group
	db := dal.GetDB()
	adminID := ctx.Value(auth.UserCtxKey).(int)
	currentTime := time.Now()
	outputFormat := "2006-01-02 15:04:05-07:00"
	currentFormattedTime := currentTime.Format(outputFormat)
	errIfNoRows := db.QueryRow(
		"INSERT INTO public.groups( name, admin_id, created_at) VALUES ( $1, $2, $3)  RETURNING id;", input.Name, adminID, currentFormattedTime).Scan(&Group.ID)
	if errIfNoRows == nil {
		Group.CreatedAt = currentFormattedTime
		return &Group, nil
	}
	return nil, errIfNoRows
}

// Videos is the resolver for the Videos field.
func (r *queryResolver) Videos(ctx context.Context, limit *int, offset *int) ([]*model.Video, error) {
	panic(fmt.Errorf("not implemented: Videos - Videos"))
}

// UserIDByName is the resolver for the UserIdByName field.
func (r *queryResolver) UserIDByName(ctx context.Context, name *string) (int, error) {
	db := dal.GetDB()
	var UserID int
	errIfNoRows := db.QueryRow("select id from public.users where fullname=$1", name).Scan(&UserID)
	if errIfNoRows == nil {
		return UserID, nil
	}
	return 0, fmt.Errorf("no user found with that name")
}

// UserDetailsByID is the resolver for the UserDetailsByID field.
func (r *queryResolver) UserDetailsByID(ctx context.Context) (*model.User, error) {
	db := dal.GetDB()
	id := ctx.Value(auth.UserCtxKey).(int)
	var User model.User
	errIfNoRows := db.QueryRow("select fullname, email, ip_address, gender from public.users where id=$1", id).Scan(&User.Fullname, &User.Email, &User.IPAddress, &User.Gender)
	if errIfNoRows == nil {
		User.ID = id
		return &User, nil
	}
	return &User, errIfNoRows
}

// VideoPublished is the resolver for the videoPublished field.
func (r *subscriptionResolver) VideoPublished(ctx context.Context) (<-chan *model.Video, error) {
	panic(fmt.Errorf("not implemented: VideoPublished - videoPublished"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type contextKey string

var (
	UserIDCtxKey = contextKey("userID")
)

func NewRootResolvers() Config {
	c := Config{
		Resolvers: &Resolver{},
	}
	// Complexity
	// Schema Directive
	c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {
		fmt.Println(UserIDCtxKey)
		authorizationKey := ctx.Value(auth.UserCtxKey).(int)
		fmt.Println(authorizationKey)
		if authorizationKey != 0 {
			fmt.Println("with autho")
			ok, errorMessage := ValidateUserByAuthorizationKey(authorizationKey)
			if ok {
				return next(ctx)
			} else {
				return nil, errors.New(errorMessage)
			}
		} else {
			fmt.Println("no autho")
			return nil, errors.New("no authorization key")
		}
	}
	return c
}
func ValidateUserByAuthorizationKey(id int) (bool, string) {
	db := dal.GetDB()
	rows, err := db.Query("select id from public.users where id=$1", id)
	if err != nil {
		return false, "internal server error"
	}
	i := 0
	for rows.Next() {
		i += 1
	}
	defer rows.Close()
	if i == 0 {
		return false, "invalid authorization key"
	}
	return true, ""
}
