package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"chat_application/api/auth"
	"chat_application/api/dal"
	"chat_application/graph/model"
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/markbates/going/randx"
)

// GroupMembers is the resolver for the groupMembers field.
func (r *groupDetailsResolver) GroupMembers(ctx context.Context, obj *model.GroupDetails) ([]*model.GroupMemberDetails, error) {
	db := dal.GetDB()
	fmt.Println("members finding")
	rows, err := db.Query("SELECT member_id, is_removed, removed_at FROM public.group_members WHERE group_id=$1;", obj.GroupID)
	if err != nil {
		return nil, err
	}
	var GroupMembersDetails []*model.GroupMemberDetails
	for rows.Next() {
		var GroupMemberDetails model.GroupMemberDetails
		err = rows.Scan(&GroupMemberDetails.MemberID, &GroupMemberDetails.IsRemoved, &GroupMemberDetails.RemovedAt)
		if err != nil {
			return nil, err
		}
		GroupMembersDetails = append(GroupMembersDetails, &GroupMemberDetails)
	}
	// obj.GroupMembers = GroupMembersDetails
	return GroupMembersDetails, nil
}

// CreatePersonalConversation is the resolver for the createPersonalConversation field.
func (r *mutationResolver) CreatePersonalConversation(ctx context.Context, input model.NewPersonalConversation) (*model.PersonalConversation, error) {
	var PersonalConversation model.PersonalConversation
	db := dal.GetDB()
	senderID := ctx.Value(auth.UserCtxKey).(string)
	currentFormattedTime := currentTimeConvertToCurrentFormattedTime()
	errIfNoRows := db.QueryRow(
		"INSERT INTO public.personal_conversations( sender_id, receiver_id, content, created_at) VALUES ( $1, $2, $3, $4)  RETURNING id, created_at;", senderID, input.ReceiverID, input.Content, currentFormattedTime).Scan(&PersonalConversation.ID, &PersonalConversation.CreatedAt)
	if errIfNoRows == nil {
		PersonalConversation.SenderID = senderID
		PersonalConversation.ReceiverID = input.ReceiverID
		PersonalConversation.Content = input.Content
		go func() {
			for id, _ := range senderAndReceiverMap {
				fmt.Println("sub running")
				if (senderAndReceiverMap[id]["senderID"] == senderID && senderAndReceiverMap[id]["receiverID"] == input.ReceiverID) || (senderAndReceiverMap[id]["senderID"] == input.ReceiverID && senderAndReceiverMap[id]["receiverID"] == senderID) {
					fmt.Println("sender and receiver varified")
					personalConversationPublishedChannelMap[id] <- &PersonalConversation
				}
			}
		}()
		return &PersonalConversation, nil
	}
	return nil, errIfNoRows
}

// CreateGroupConversation is the resolver for the createGroupConversation field.
func (r *mutationResolver) CreateGroupConversation(ctx context.Context, input model.NewGroupConversation) (*model.GroupConversation, error) {
	var GroupConversation model.GroupConversation
	db := dal.GetDB()
	senderID := ctx.Value(auth.UserCtxKey).(string)
	var removedFromGroup bool
	errIfNoRows := db.QueryRow(
		"SELECT is_removed FROM public.group_members WHERE member_id=$1 AND group_id=$2;", senderID, input.GroupID).Scan(&removedFromGroup)
	if errIfNoRows != nil {
		return nil, fmt.Errorf("user is not member of group")
	}
	if removedFromGroup {
		return nil, fmt.Errorf("user is no more member of group")
	}
	currentFormattedTime := currentTimeConvertToCurrentFormattedTime()
	errIfNoRows = db.QueryRow(
		"INSERT INTO public.group_conversations( group_id, sender_id, content, created_at) VALUES ( $1, $2, $3, $4)  RETURNING id, created_at;", input.GroupID, senderID, input.Content, currentFormattedTime).Scan(&GroupConversation.ID, &GroupConversation.CreatedAt)
	if errIfNoRows == nil {
		GroupConversation.SenderID = senderID
		GroupConversation.GroupID = input.GroupID
		GroupConversation.Content = input.Content
		go func() {
			for id, _ := range groupAndMemberMap {
				fmt.Println("sub running")
				if groupAndMemberMap[id]["groupID"] == input.GroupID {
					groupConversationPublishedChannelMap[id] <- &GroupConversation
				}
			}
		}()
		return &GroupConversation, nil
	}
	return nil, errIfNoRows
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, input model.NewGroup) (*model.Group, error) {
	var Group model.Group
	db := dal.GetDB()
	adminID := ctx.Value(auth.UserCtxKey).(string)
	currentFormattedTime := currentTimeConvertToCurrentFormattedTime()
	tx, err := db.Begin()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	err = tx.QueryRow("INSERT INTO public.groups( name, admin_id, created_at) VALUES ( $1, $2, $3)  RETURNING id, created_at;", input.Name, adminID, currentFormattedTime).Scan(&Group.ID, &Group.CreatedAt)
	if err != nil {
		return nil, err
	}

	_, err = tx.Exec("INSERT INTO public.group_members (group_id, member_id) VALUES ($1, $2)", Group.ID, adminID)
	if err != nil {
		return nil, err
	}

	content := fmt.Sprintf("Group created :- %v", input.Name)
	_, err = tx.Exec("INSERT INTO public.group_conversations( group_id, sender_id, content, created_at) VALUES ( $1, $2, $3, $4)  RETURNING id, created_at;", Group.ID, adminID, content, currentFormattedTime)
	if err != nil {
		return nil, err
	}

	// Commit the transaction
	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	Group.AdminID = adminID
	Group.Name = input.Name
	return &Group, nil
}

// AddGroupMembers is the resolver for the addGroupMembers field.
func (r *mutationResolver) AddGroupMembers(ctx context.Context, input model.GroupMembersInput) (bool, error) {
	adminID := ctx.Value(auth.UserCtxKey).(string)
	db := dal.GetDB()
	err := checkUserIsAdminOfGroup(db, adminID, input.GroupID)
	if err != nil {
		return false, fmt.Errorf("user is not admin group")
	}
	tx, err := db.Begin()
	if err != nil {
		return false, err
	}
	defer tx.Rollback()
	currentFormattedTime := currentTimeConvertToCurrentFormattedTime()
	for i, _ := range input.MemberID {
		_, err := tx.Exec("UPSERT INTO public.group_members (group_id, member_id) VALUES ($1, $2);", input.GroupID, input.MemberID[i])
		if err != nil {
			return false, fmt.Errorf("wrong memberid")
		}
		memberName, err := r.Query().UserNameByID(ctx, input.MemberID[i])
		if err != nil {
			return false, fmt.Errorf("wrong memberid")
		}
		content := fmt.Sprintf("%s added in to the group", memberName)
		_, err = tx.Exec("INSERT INTO public.group_conversations( group_id, sender_id, content, created_at) VALUES ( $1, $2, $3, $4)  RETURNING id, created_at;", input.GroupID, adminID, content, currentFormattedTime)
		if err != nil {
			return false, err
		}
	}
	// Commit the transaction
	err = tx.Commit()
	if err != nil {
		return false, err
	}
	return true, nil
}

// RemoveGroupMembers is the resolver for the removeGroupMembers field.
func (r *mutationResolver) RemoveGroupMembers(ctx context.Context, input model.GroupMembersInput) (bool, error) {
	adminID := ctx.Value(auth.UserCtxKey).(string)
	db := dal.GetDB()
	err := checkUserIsAdminOfGroup(db, adminID, input.GroupID)
	if err != nil {
		return false, fmt.Errorf("user is not admin group")
	}
	tx, err := db.Begin()
	if err != nil {
		return false, err
	}
	defer tx.Rollback()
	currentFormattedTime := currentTimeConvertToCurrentFormattedTime()
	for i, _ := range input.MemberID {
		_, err = tx.Exec("UPDATE public.group_members SET is_removed=true, removed_at=$1 WHERE group_id=$2 AND member_id=$3;", currentFormattedTime, input.GroupID, input.MemberID[i])
		if err != nil {
			return false, err
		}
		memberName, err := r.Query().UserNameByID(ctx, input.MemberID[i])
		if err != nil {
			return false, fmt.Errorf("wrong memberid")
		}
		content := fmt.Sprintf("%s removed from the group", memberName)
		_, err = tx.Exec("INSERT INTO public.group_conversations( group_id, sender_id, content, created_at) VALUES ( $1, $2, $3, $4)  RETURNING id, created_at;", input.GroupID, adminID, content, currentFormattedTime)
		if err != nil {
			return false, err
		}
	}
	// Commit the transaction
	err = tx.Commit()
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeletePersonalConversation is the resolver for the deletePersonalConversation field.
func (r *mutationResolver) DeletePersonalConversation(ctx context.Context, messageID string) (bool, error) {
	senderID := ctx.Value(auth.UserCtxKey).(string)
	db := dal.GetDB()
	result, err := db.Exec("DELETE FROM public.personal_conversations WHERE sender_id=$1 AND id=$2;", senderID, messageID)
	if err != nil {
		return false, err
	}
	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("wrong data")
	}
	return true, nil
}

// DeleteGroupConversation is the resolver for the deleteGroupConversation field.
func (r *mutationResolver) DeleteGroupConversation(ctx context.Context, input model.DeleteGroupConversationInput) (bool, error) {
	senderID := ctx.Value(auth.UserCtxKey).(string)
	db := dal.GetDB()
	var removedFromGroup bool
	errIfNoRows := db.QueryRow(
		"SELECT is_removed FROM public.group_members WHERE member_id=$1 AND group_id=$2;", senderID, input.GroupID).Scan(&removedFromGroup)
	if errIfNoRows != nil {
		return false, fmt.Errorf("user is not member of group")
	}
	if removedFromGroup {
		return false, fmt.Errorf("user is no more member of group")
	}
	result, err := db.Exec("DELETE FROM public.group_conversations WHERE sender_id=$1 AND id=$2;", senderID, input.MessageID)
	if err != nil {
		return false, err
	}
	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("wrong data")
	}
	return true, nil
}

// GroupDetails is the resolver for the GroupDetails field.
func (r *queryResolver) GroupDetails(ctx context.Context, groupID string) (*model.GroupDetails, error) {
	memberID := ctx.Value(auth.UserCtxKey).(string)
	db := dal.GetDB()

	var GroupDetails model.GroupDetails
	errIfNoRows := db.QueryRow(
		"SELECT name, admin_id, created_at FROM public.groups WHERE id=$1;", groupID).Scan(&GroupDetails.Name, &GroupDetails.AdminID, &GroupDetails.CreatedAt)
	if errIfNoRows != nil {
		return nil, errIfNoRows
	}
	fmt.Println("group details called")
	var removedFromGroup bool
	errIfNoRows = db.QueryRow(
		"SELECT is_removed FROM public.group_members WHERE member_id=$1 AND group_id=$2;", memberID, groupID).Scan(&removedFromGroup)
	if errIfNoRows != nil {
		return nil, fmt.Errorf("user is not member of group")
	}
	GroupDetails.GroupID = groupID
	if removedFromGroup {
		return &GroupDetails, nil
	}

	return &GroupDetails, nil
}

// UserList is the resolver for the UserList field.
func (r *queryResolver) UserList(ctx context.Context, input *model.UserListInput) ([]*model.User, error) {
	db := dal.GetDB()
	offset := (*input.Page - 1) * *input.Limit
	var where, orderBy []string
	var whereKeyword string
	var filterArgsList []interface{}

	if input.Name != nil && *input.Name != "" {
		where = append(where, "fullname ILIKE '%' || ? || '%'")
		filterArgsList = append(filterArgsList, *input.Name)
		orderBy = append(orderBy, "POSITION (LOWER('"+*input.Name+"') IN LOWER(fullname)) ASC")
	}
	if input.Email != nil && *input.Email != "" {
		where = append(where, "email ILIKE '%' || ? || '%'")
		filterArgsList = append(filterArgsList, *input.Email)
		orderBy = append(orderBy, "POSITION (LOWER('"+*input.Email+"') IN LOWER(email)) ASC")
	}
	if len(where) > 0 {
		whereKeyword = "WHERE"
	} else {
		orderBy = append(orderBy, "fullname ASC")
	}
	// fmt.Println(wh)
	query := fmt.Sprintf("SELECT id, fullname, email, ip_address, gender FROM public.users %s %v ORDER BY %v LIMIT %d OFFSET %d", whereKeyword, strings.Join(where, " OR "), strings.Join(orderBy, " , "), *input.Limit, offset)
	query = sqlx.Rebind(sqlx.DOLLAR, query)
	fmt.Println(query)
	rows, err := db.Query(query, filterArgsList...)
	if err != nil {
		return nil, err
	}
	var Users []*model.User
	for rows.Next() {
		var User model.User
		err = rows.Scan(&User.ID, &User.Fullname, &User.Email, &User.IPAddress, &User.Gender)
		if err != nil {
			return nil, err
		}
		Users = append(Users, &User)
	}
	return Users, nil
}

// AddableMembersInGroup is the resolver for the addableMembersInGroup field.
func (r *queryResolver) AddableMembersInGroup(ctx context.Context, input model.AddableMembersInGroupInput) ([]*model.User, error) {
	db := dal.GetDB()
	userID := ctx.Value(auth.UserCtxKey).(string)
	err := checkUserIsAdminOfGroup(db, userID, input.GroupID)
	if err != nil {
		return nil, fmt.Errorf("user is not admin group")
	}
	offset := (*input.Page - 1) * *input.Limit
	var where, orderBy []string
	var andKeyword string
	var filterArgsList []interface{}

	if input.Name != nil && *input.Name != "" {
		where = append(where, "fullname ILIKE '%' || ? || '%'")
		filterArgsList = append(filterArgsList, *input.Name)
		orderBy = append(orderBy, "POSITION (LOWER('"+*input.Name+"') IN LOWER(fullname)) ASC")
	}
	if input.Email != nil && *input.Email != "" {
		where = append(where, "email ILIKE '%' || ? || '%'")
		filterArgsList = append(filterArgsList, *input.Email)
		orderBy = append(orderBy, "POSITION (LOWER('"+*input.Email+"') IN LOWER(email)) ASC")
	}
	if len(where) > 0 {
		postCondition := strings.Join(where, " OR ")
		andKeyword = "AND (" + postCondition + ")"
	} else {
		orderBy = append(orderBy, "fullname ASC")
	}
	preCondition := "id IN (SELECT id FROM public.users EXCEPT SELECT member_id FROM public.group_members WHERE group_id = " + input.GroupID + " AND is_removed = false )"
	query := fmt.Sprintf("SELECT id, fullname, email, ip_address, gender FROM public.users WHERE %s %s ORDER BY %v LIMIT %d OFFSET %d", preCondition, andKeyword, strings.Join(orderBy, " , "), *input.Limit, offset)
	query = sqlx.Rebind(sqlx.DOLLAR, query)
	fmt.Println(query)
	rows, err := db.Query(query, filterArgsList...)
	if err != nil {
		return nil, err
	}
	var Users []*model.User
	for rows.Next() {
		var User model.User
		err = rows.Scan(&User.ID, &User.Fullname, &User.Email, &User.IPAddress, &User.Gender)
		if err != nil {
			return nil, err
		}
		Users = append(Users, &User)
	}
	return Users, nil
}

// UserDetailsByID is the resolver for the UserDetailsByID field.
func (r *queryResolver) UserDetailsByID(ctx context.Context, userID string) (*model.User, error) {
	db := dal.GetDB()
	id := ctx.Value(auth.UserCtxKey).(string)
	var User model.User
	errIfNoRows := db.QueryRow("SELECT fullname, email, ip_address, gender FROM public.users WHERE id=$1", id).Scan(&User.Fullname, &User.Email, &User.IPAddress, &User.Gender)
	if errIfNoRows == nil {
		User.ID = id
		return &User, nil
	}
	return &User, errIfNoRows
}

// UserNameByID is the resolver for the UserNameById field.
func (r *queryResolver) UserNameByID(ctx context.Context, userID string) (string, error) {
	db := dal.GetDB()
	var name string
	errIfNoRows := db.QueryRow("SELECT fullname FROM public.users WHERE id=$1", userID).Scan(&name)
	if errIfNoRows == nil {
		return name, nil
	}
	return "", fmt.Errorf("no user found with that id")
}

// PersonalConversationRecords is the resolver for the PersonalConversationRecords field.
func (r *queryResolver) PersonalConversationRecords(ctx context.Context, limit *int, offset *int, receiverID string) ([]*model.PersonalConversation, error) {
	db := dal.GetDB()
	userID := ctx.Value(auth.UserCtxKey).(string)
	rows, err := db.Query(
		"SELECT sender_id, receiver_id, content, created_at, id FROM public.personal_conversations WHERE (sender_id = $1 AND receiver_id = $2) OR (sender_id = $2 AND receiver_id = $1) ORDER BY created_at DESC LIMIT $3 OFFSET $4 ", userID, receiverID, limit, offset)
	if err != nil {
		return nil, err
	}
	var PersonalConversations []*model.PersonalConversation
	for rows.Next() {
		var PersonalConversation model.PersonalConversation
		err = rows.Scan(&PersonalConversation.SenderID, &PersonalConversation.ReceiverID, &PersonalConversation.Content, &PersonalConversation.CreatedAt, &PersonalConversation.ID)
		if err != nil {
			return nil, err
		}
		PersonalConversations = append(PersonalConversations, &PersonalConversation)
	}
	return PersonalConversations, nil
}

// GroupConversationRecords is the resolver for the GroupConversationRecords field.
func (r *queryResolver) GroupConversationRecords(ctx context.Context, limit *int, offset *int, groupID string) ([]*model.GroupConversation, error) {
	db := dal.GetDB()
	UserID := ctx.Value(auth.UserCtxKey).(string)
	var removedFromGroup bool
	var removedAt *string
	errIfNoRows := db.QueryRow(
		"SELECT is_removed,removed_at FROM public.group_members WHERE member_id=$1 AND group_id=$2;", UserID, groupID).Scan(&removedFromGroup, &removedAt)
	if errIfNoRows != nil {
		return nil, fmt.Errorf("invalid groupid or memberid")
	}
	var rows *sql.Rows
	var err error
	if removedFromGroup {
		rows, err = db.Query("SELECT id, sender_id, content, created_at FROM public.group_conversations WHERE group_id = $1 AND created_at <= $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4 ", groupID, *removedAt, limit, offset)
	} else {
		rows, err = db.Query("SELECT id, sender_id, content, created_at FROM public.group_conversations WHERE group_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3 ", groupID, limit, offset)
	}
	if err != nil {
		return nil, err
	}
	var GroupConversations []*model.GroupConversation
	for rows.Next() {
		var GroupConversation model.GroupConversation
		GroupConversation.GroupID = groupID
		err = rows.Scan(&GroupConversation.ID, &GroupConversation.SenderID, &GroupConversation.Content, &GroupConversation.CreatedAt)
		if err != nil {
			return nil, err
		}
		GroupConversations = append(GroupConversations, &GroupConversation)
	}
	return GroupConversations, nil
}

// RecentConversationList is the resolver for the RecentConversationList field.
func (r *queryResolver) RecentConversationList(ctx context.Context, limit *int, offset *int) ([]*model.ConversationList, error) {
	db := dal.GetDB()
	UserID := ctx.Value(auth.UserCtxKey).(string)
	rows, err := db.Query(
		`
		SELECT
			last_message_time,
			conversation_id,
			is_it_group
		FROM
			(
			SELECT
				CASE
					WHEN is_removed = true THEN removed_at
					ELSE MAX(created_at)
				END AS last_message_time,
				gc.group_id AS conversation_id,
				'true' AS is_it_group
			FROM
				public.group_conversations gc
			INNER JOIN public.group_members gm ON
				gc.group_id = gm.group_id
			WHERE
				gc.group_id IN (
				SELECT
					group_id
				FROM
					public.group_members
				WHERE
					member_id = $1
		    )
				AND gm.member_id = $1
			GROUP BY
				(gc.group_id,
				gm.is_removed,
				gm.removed_at)
		UNION
			SELECT
				MAX(created_at) AS last_message_time,
				CASE
					WHEN sender_id = $1 THEN receiver_id
					ELSE sender_id
				END AS recent_conversation_id,
				'false' AS is_it_group
			FROM
				public.personal_conversations
			WHERE
				sender_id = $1
				OR receiver_id = $1
			GROUP BY
				recent_conversation_id
		)
		ORDER BY
			last_message_time DESC
		LIMIT $2 OFFSET $3;`, UserID, limit, offset)
	if err != nil {
		return nil, err
	}
	var ConversationList []*model.ConversationList
	for rows.Next() {
		var Conversation model.ConversationList
		err = rows.Scan(&Conversation.LastMessageTime, &Conversation.ConversationID, &Conversation.IsItGroup)
		if err != nil {
			return nil, err
		}
		ConversationList = append(ConversationList, &Conversation)
	}
	return ConversationList, nil
}

// PersonalConversationPublished is the resolver for the personalConversationPublished field.
func (r *subscriptionResolver) PersonalConversationPublished(ctx context.Context, input model.PersonalConversationPublishedInput) (<-chan *model.PersonalConversation, error) {
	id := randx.String(8)
	// fmt.Println(id)
	// printAllocatedMemory()
	personalConversationEvent := make(chan *model.PersonalConversation, 1)
	go func() {
		<-ctx.Done()
		defer clearSubscriptionVariablesOfPersonalConversation(id)
	}()
	senderAndReceiverMap[id] = map[string]string{"senderID": input.SenderID, "receiverID": input.ReceiverID}
	personalConversationPublishedChannelMap[id] = personalConversationEvent
	// fmt.Println("after allocating variable")

	// printAllocatedMemory()
	// runtime.KeepAlive(senderAndReceiverMap) // Keeps a reference to m so that the map isn’t collected
	return personalConversationEvent, nil
}

// GroupConversationPublished is the resolver for the groupConversationPublished field.
func (r *subscriptionResolver) GroupConversationPublished(ctx context.Context, input model.GroupConversationPublishedInput) (<-chan *model.GroupConversation, error) {
	db := dal.GetDB()
	var removedFromGroup bool
	errIfNoRows := db.QueryRow(
		"SELECT is_removed FROM public.group_members WHERE member_id=$1 AND group_id=$2;", input.MemberID, input.GroupID).Scan(&removedFromGroup)
	if errIfNoRows != nil {
		return nil, fmt.Errorf("invalid groupid or memberid")
	}
	if removedFromGroup {
		return nil, fmt.Errorf("user is no more member of group")
	}
	id := randx.String(8)
	// fmt.Println(id)
	fmt.Println("GroupConversationPublished running")
	groupConversationEvent := make(chan *model.GroupConversation, 1)
	go func() {
		<-ctx.Done()
		defer clearSubscriptionVariablesOfGroupConversation(id)
	}()
	groupAndMemberMap[id] = map[string]string{"groupID": input.GroupID}
	groupConversationPublishedChannelMap[id] = groupConversationEvent
	return groupConversationEvent, nil
}

// GroupDetails returns GroupDetailsResolver implementation.
func (r *Resolver) GroupDetails() GroupDetailsResolver { return &groupDetailsResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type groupDetailsResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var groupConversationPublishedChannelMap map[string]chan *model.GroupConversation
var personalConversationPublishedChannelMap map[string]chan *model.PersonalConversation
var senderAndReceiverMap = make(map[string]map[string]string)
var groupAndMemberMap = make(map[string]map[string]string)

func init() {
	personalConversationPublishedChannelMap = map[string]chan *model.PersonalConversation{}
	groupConversationPublishedChannelMap = map[string]chan *model.GroupConversation{}
}

type contextKey string

var (
	UserIDCtxKey = contextKey("userID")
)

func clearSubscriptionVariablesOfPersonalConversation(id string) {
	delete(senderAndReceiverMap, id)
	delete(personalConversationPublishedChannelMap, id)
}
func clearSubscriptionVariablesOfGroupConversation(id string) {
	delete(groupAndMemberMap, id)
	delete(groupConversationPublishedChannelMap, id)
}
func checkUserIsAdminOfGroup(db *sql.DB, adminID string, groupID string) error {
	errIfNoRows := db.QueryRow("SELECT admin_id FROM public.groups WHERE admin_id = $1 AND id = $2;", adminID, groupID).Scan(&adminID)
	fmt.Println(adminID, groupID)
	return errIfNoRows
}
func currentTimeConvertToCurrentFormattedTime() string {
	currentTime := time.Now()
	outputFormat := "2006-01-02 15:04:05-07:00"
	currentFormattedTime := currentTime.Format(outputFormat)
	return currentFormattedTime
}
